<?phpnamespace BinanceProducer\Api;use PhpAmqpLib\Connection\AMQPStreamConnection;use PhpAmqpLib\Message\AMQPMessage;use WebSocket\Client;class Binance{    protected $base = 'https://api.binance.com/api/', $api_key, $api_secret;    CONST BINANCE_WEB_SERVICE = 'wss://stream.binance.com:9443/ws/';    CONST TICKER_LIST = [        'btcusdt',        'ethusdt'    ];    CONST KLINE_INTERVAL = '1m';    /**     * @var null     */    private $rabbitConnection;    /**     * @var null     */    private $rabbitChannel;    /**     * @var string     */    private $rabbitUrl;    /**     * @var Client     */    private $binanceClient;    public function __construct(string $rabbitUrl, $api_key = null, $api_secret = null) {        $this->api_key = $api_key;        $this->api_secret = $api_secret;        $this->binanceClient =  new Client(self::BINANCE_WEB_SERVICE);        $this->rabbitConnection = null;        $this->rabbitChannel = null;        $this->rabbitUrl = $rabbitUrl;    }    public function startStream()    {        $this->rabbitConnection = new AMQPStreamConnection($this->rabbitUrl, 5672, 'guest', 'guest');        $this->rabbitChannel = $this->rabbitConnection->channel();        while (true) {            try {                $tickerData = $this->getDataFromTickers();                $this->sendTickerData($tickerData);                print_r("tick...");                echo "\n";                print_r($tickerData);                echo "\n";            } catch (\WebSocket\ConnectionException $e) {                // Possibly log errors                print_r("Error: ".$e->getMessage());                echo "\n";            }        }        $this->rabbitChannel->close();        $this->rabbitConnection->close();        $connection->close();    }    private function getDataFromTickers() {        $tickerData = [];        foreach (self::TICKER_LIST as $ticker) {            $endpoint = $ticker . '@kline_'.self::KLINE_INTERVAL;            $tickerData[] = $this->getBinanceClient($endpoint)->receive();        }        return $tickerData;    }    private function sendTickerData(array $tickerData) {        foreach ($tickerData as $data) {            $formattedData = $this->formatData($data);            $this->rabbitPost($formattedData);        }    }    private function formatData($response) {        $data = json_decode($response);        $priceFloat = floatval($data->k->c);        $currentValue = intval($priceFloat * 100);        $toSend = [            'timestamp' => $data->E,            'currentValue' => $currentValue,            'exchangeName' => 'BINANCE',            "coin" => $data->s        ];        return json_encode($toSend);    }    private function getBinanceClient(string $endpoint): Client {        return new Client(self::BINANCE_WEB_SERVICE.$endpoint);    }    private function rabbitPost($data) {        $msg = new AMQPMessage($data);        $this->rabbitChannel->basic_publish($msg, 'ingestor_exchange', 'exchange_queue');    }}